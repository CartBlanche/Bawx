using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework.Graphics;

namespace Bawx
{
    public static class GreedyMesh
    {

        // C# port adapted from https://www.giawa.com/journal-entry-6-greedy-mesh-optimization/
        // I rewrote some parts for readability and so I got a better understanding of the code
        // Functional changes:
        // - backfaces and frontfaces are handled seperately so we can set the right normals and have backface culling
        // - faces are compared to check if they can be merged (e.g. if they have a different material they can't be merged)

        /// <summary>
        /// Generate a mesh from the given voxel data. Greedily creates quads from aligned faces.
        /// </summary>
        /// <typeparam name="T">The type of vertices to generate.</typeparam>
        /// <param name="grid">A 3d grid containing the voxel data.</param>
        /// <param name="createQuad">The function used to create a quad. Arguments in order:
        ///  - int[] p: position {x, y, z}
        ///  - int[] du, dv: unit vectors that contain the direction of the quad
        ///  - int w, h: width and height of the quad. w is in du direction and h in dv direction
        ///  - VoxelFace face: extra data of the face that should be put in the vertices
        ///  - bool backFace: determines direction of the normal
        /// If the order is different indices will not match up.</param>
        /// <param name="vertices">The resulting vertices generated by the algorithm.</param>
        /// <param name="indices">The indices that can be used together with <see cref="vertices"/> to render the quads.</param>
        /// <param name="cw">Determines quad winding. CCW when left at false, CW when set to true.</param>
        public static void Generate<T>(byte[][][] grid, Func<int[], int[], int[], int, bool, VoxelFace, bool, IEnumerable<T>> createQuad, 
            out T[] vertices, out int[] indices, bool cw = false) where T : IVertexType
        {
            // This greedy algorithm is converted from JavaScript to C# from this article:
            // http://0fps.wordpress.com/2012/06/30/meshing-in-a-minecraft-game/
            //
            // The original source code can be found here:
            // https://github.com/mikolalysenko/mikolalysenko.github.com/blob/gh-pages/MinecraftMeshes/js/greedy.js
            var verts = new List<T>();
            var inds = new List<int>();

            int[] size = {grid.Length, grid[0].Length, grid[0][0].Length};
            // loop over the three directions; x -> 0, y -> 1, z -> 2
            for (var direction = 0; direction < 3; direction++)
            {
                // u and v are the other two directions
                var u = (direction + 1)%3;
                var v = (direction + 2)%3;

                // pos holds the current position in the grid
                var pos = new int[3];
                // 1 for the current direction and 0 for others, unit vector of the axis we're handling
                var nextPos = new int[3];
                // contains the rendering data for each face in the current layers, a layer being a slice of the grid; Note that this is linearized
                var backFaces = new VoxelFace[grid.GetSize(u)*grid.GetSize(v)];
                var frontFaces = new VoxelFace[grid.GetSize(u)*grid.GetSize(v)];

                nextPos[direction] = 1;

                // outer loop goes through all layers
                // we start at -1 because we check for faces *between* blocks and have to get the outer faces too
                for (pos[direction] = -1; pos[direction] < grid.GetSize(direction); pos[direction]++)
                {
                    var noBack = true;
                    var noFront = true;
                    // Get all faces that need to be rendered in the current layer (front and back seperately)
                    for (pos[v] = 0; pos[v] < size[v]; pos[v]++)
                    {
                        for (pos[u] = 0; pos[u] < size[u]; pos[u]++)
                        {
                            // if this block is visible and the one behind it is not we need to render the backface of the current block
                            // if this one is not visible but the one behind it is, we need to render the frontface of the 'behind' block
                            var index = pos[v]*size[u] + pos[u];
                            var current = pos[direction] >= 0 && !grid[pos[0]][pos[1]][pos[2]].IsEmpty();
                            var behind = pos[direction] + 1 < grid.GetSize(direction) &&
                                         !grid[pos[0] + nextPos[0]][pos[1] + nextPos[1]][pos[2] + nextPos[2]].IsEmpty();

                            if (current && !behind)
                            {
                                backFaces[index] = new VoxelFace(grid[pos[0]][pos[1]][pos[2]]);
                                noBack = false;
                            }
                            else if (!current && behind)
                            {
                                frontFaces[index] = new VoxelFace(grid[pos[0] + nextPos[0]][pos[1] + nextPos[1]][pos[2] + nextPos[2]]);
                                noFront = false;
                            }
                        }
                    }

                    // Then process both layers to build quads
                    if (!noFront)
                        ProcessLayer(frontFaces, createQuad, verts, inds, pos[direction] + 1, direction, size, cw, false);
                    if (!noBack)
                        ProcessLayer(backFaces, createQuad, verts, inds, pos[direction] + 1, direction, size, !cw, true);
                }
            }

            vertices = verts.ToArray();
            indices = inds.ToArray();
        }

        private static void ProcessLayer<T>(
            VoxelFace[] faces, Func<int[], int[], int[], int, bool, VoxelFace, bool, IEnumerable<T>> createQuad, 
            List<T> vertices, List<int> indices,
            int depth, int dir, int[] size, bool cw, bool positiveNormal) where T : IVertexType
        {
            var u = (dir + 1)%3;
            var v = (dir + 2)%3;


            // Generate mesh for mask using lexicographic ordering
            for (var v0 = 0; v0 < size[v]; v0++)
            {
                for (var u0 = 0; u0 < size[u]; u0++)
                {
                    var n = v0*size[u] + u0;
                    if (faces[n].IsEmpty) continue;

                    var currentFace = faces[n];
                    // Compute width
                    var u1 = 1;
                    while (u0 + u1 < size[u] && currentFace == faces[n + u1]) u1++;

                    // Compute height
                    int v1;
                    for (v1 = 1; v0 + v1 < size[v]; v1++)
                    {
                        for (var k = 0; k < u1; k++)
                        {
                            if (faces[n + k + v1*size[u]] != currentFace)
                                goto EndLoop;
                        }
                    }

                    EndLoop:

                    // contains starting position
                    var pos = new int[3];
                    pos[dir] = depth;
                    pos[u] = u0;
                    pos[v] = v0;
                    // contains width and height
                    var du = new int[3];
                    du[u] = u1;
                    var dv = new int[3];
                    dv[v] = v1;

                    // Add quad
                    indices.AddRange(CreateQuadIndices(vertices.Count, cw));
                    var quadVerts = createQuad(pos, du, dv, dir, positiveNormal, currentFace, cw);
                    vertices.AddRange(quadVerts);

                    // Zero-out mask
                    for (var l = 0; l < v1; ++l)
                        for (var k = 0; k < u1; ++k)
                            faces[n + k + l*size[u]] = VoxelFace.Empty;

                    u0 += u1 - 1;
                }
            }
        }

        private static int[] CreateQuadIndices(int start, bool cw)
        {
            if (cw)
            {
                return new []
                {
                    start, start + 3, start + 2,
                    start + 2, start + 1, start
                };
            }
            return new []
            {
                start, start + 1, start + 2,
                start + 2, start + 3, start
            };
        }

        #region Methods

        // Use extension methods so this can easily be refactored later in case blocks become more complex
        private static bool IsEmpty(this byte b)
        {
            return b == 0;
        }

        private static int GetSize<T>(this T[][][] grid, int dimension)
        {
            switch (dimension)
            {
                // X
                case 0:
                    return grid.Length;
                // Y
                case 1:
                    return grid[0].Length;
                // Z
                case 2:
                    return grid[0][0].Length;
                default:
                    throw new ArgumentOutOfRangeException(nameof(dimension));
            }
        }

        #endregion

        public struct VoxelFace
        {
            public readonly byte Index;

            public bool IsEmpty => Index == 0;

            public VoxelFace(byte index)
            {
                Index = index;
            }

            public static VoxelFace Empty => new VoxelFace(0);

            public bool Equals(VoxelFace other)
            {
                return Index == other.Index;
            }

            public override bool Equals(object obj)
            {
                if (ReferenceEquals(null, obj)) return false;
                return obj is VoxelFace && Equals((VoxelFace) obj);
            }

            public override int GetHashCode()
            {
                return Index.GetHashCode();
            }

            public static bool operator ==(VoxelFace left, VoxelFace right)
            {
                return left.Equals(right);
            }

            public static bool operator !=(VoxelFace left, VoxelFace right)
            {
                return !left.Equals(right);
            }
        }
    }

}